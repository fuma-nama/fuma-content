import { Ajv2020 } from "ajv/dist/2020";
import { createContext, ReactNode, use, useMemo } from "react";
import { getDefaultValue } from "./get-default-values";
import type { JSONSchema } from "json-schema-typed/draft-2020-12";
import { mergeAllOf } from "./utils/merge-schema";
import { FieldKey, useDataEngine, useFieldValue } from "@fumari/stf";
import { stringifyFieldKey } from "@fumari/stf/lib/utils";

interface EditorContextType {
  schema: JSONSchema;
  ajv: Ajv2020;
  yjs?: YjsContext;
}

export interface YjsContext {
  field: string;
}

export type EditorContextProps = Omit<EditorContextType, "ajv"> & { children: ReactNode };

type UnionField = "anyOf" | "oneOf";

export interface FieldInfo {
  selectedType?: string;
  oneOf: number;

  /**
   * The actual field that represents union members.
   */
  unionField?: UnionField;

  intersection?: {
    merged: Exclude<JSONSchema, boolean>;
  };
}

const SchemaContext = createContext<EditorContextType | undefined>(undefined);
export const anyFields = {
  type: ["string", "number", "boolean", "array", "object"],
  items: true,
  additionalProperties: true,
} satisfies JSONSchema;

export function EditorProvider({ schema, yjs, children }: EditorContextProps) {
  const ajv = useMemo(
    () =>
      new Ajv2020({
        strict: false,
        validateSchema: false,
        validateFormats: false,
        schemas: [schema],
      }),
    [schema],
  );

  return (
    <SchemaContext.Provider value={useMemo(() => ({ schema, ajv, yjs }), [schema, ajv, yjs])}>
      {children}
    </SchemaContext.Provider>
  );
}

/**
 * A hook to store dynamic info of a field, such as selected schema of `oneOf`.
 *
 * @param fieldName - field name of form.
 * @param schema - The JSON Schema to generate initial values.
 * @param depth - The depth to avoid duplicated field name with same schema (e.g. nested `oneOf`).
 */
export function useFieldInfo(
  fieldName: FieldKey,
  schema: Exclude<JSONSchema, boolean>,
): {
  info: FieldInfo;
  updateInfo: (value: Partial<FieldInfo>) => void;
} {
  const { ajv } = use(SchemaContext)!;
  const engine = useDataEngine();
  const fieldData = engine.namespace(`field-info:${stringifyFieldKey(fieldName)}`);
  const [info, setInfo] = useFieldValue<FieldInfo>(fieldName, {
    stf: fieldData,
    defaultValue(): FieldInfo {
      const value = engine.get(fieldName);
      const out: FieldInfo = {
        oneOf: -1,
      };
      const union = getUnion(schema);
      if (union) {
        const [members, field] = union;

        out.oneOf = members.findIndex((item) => ajv.validate(item, value));
        if (out.oneOf === -1) out.oneOf = 0;
        out.unionField = field;
      }

      if (Array.isArray(schema.type)) {
        const types = schema.type;

        out.selectedType =
          types.find((type) => ajv.validate({ ...schema, type }, value)) ?? types.at(0);
      }

      if (schema.allOf) {
        const merged = mergeAllOf(schema);

        if (typeof merged !== "boolean")
          out.intersection = {
            merged,
          };
      }

      return out;
    },
  });

  return {
    info,
    updateInfo(value) {
      const updated = {
        ...info,
        ...value,
      };

      if (updated.oneOf === info.oneOf && updated.selectedType === info.selectedType) return;

      setInfo(updated);

      let valueSchema: JSONSchema = schema;
      if (updated.unionField) {
        valueSchema = schema[updated.unionField]![updated.oneOf];
      } else if (updated.selectedType) {
        valueSchema = { ...schema, type: updated.selectedType };
      }

      engine.update(fieldName, getDefaultValue(valueSchema));
    },
  };
}

export function useEditorContext() {
  return use(SchemaContext)!;
}

/**
 * Resolve `$ref` in the schema, **not recursive**.
 */
export function useResolvedSchema(schema: JSONSchema): Exclude<JSONSchema, boolean> {
  const { ajv } = use(SchemaContext)!;

  return useMemo(() => fallbackAny(dereference(schema, { ajv })), [ajv, schema]);
}

export function fallbackAny(schema: JSONSchema): Exclude<JSONSchema, boolean> {
  return typeof schema === "boolean" ? anyFields : schema;
}

function getUnion(
  schema: Exclude<JSONSchema, boolean>,
): [readonly JSONSchema[], UnionField] | undefined {
  if (schema.anyOf) {
    return [schema.anyOf, "anyOf"];
  }

  if (schema.oneOf) return [schema.oneOf, "oneOf"];
}

/**
 * resolve refs (non-recursive)
 */
export function dereference(
  schema: JSONSchema,
  { ajv }: Pick<EditorContextType, "ajv">,
): JSONSchema {
  if (typeof schema === "boolean") return schema;
  if (schema.$ref) return ajv.getSchema(schema.$ref)?.schema ?? false;
  return schema;
}
