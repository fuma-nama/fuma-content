---
title: MDX Collection
description: Compile Markdown/MDX into JavaScript files.
---

## Usage

```ts title="content.config.ts"
import { defineConfig } from "fuma-content/config";
import { mdxCollection } from "fuma-content/collections/mdx";
import { z } from "zod";

const docs = mdxCollection({
  dir: "content",

  // optional: define frontmatter schema (Standard Schema compatible)
  frontmatter: z.object({
    title: z.string(),
  }),

  // optional: MDX options
  options: () => ({
    jsxImportSource: "react",
  }),
});

export default defineConfig({
  collections: { docs },
});
```

It generates:

- `<name>.ts`: server-side access to compiled properties.
- `<name>.browser.ts`: client-side access, with framework integrations for React.

```tsx tab="Server"
import { docs } from "content/docs";

for (const file of docs.list()) {
  const id = file.id;
  // compiled properties & typed frontmatter
  const { frontmatter, ...rest } = file.compiled;
}

// or from ID:
console.log(docs.get("index.mdx"));
```

```tsx tab="Server (React)"
function Page({ id }: { id: string }) {
  const file = docs.get(id);
  if (!file) return;

  // default refers to the content body renderer
  // you can render it directly in React Server Component
  const { default: MDX } = file.compiled;

  return (
    <div className="prose">
      <MDX
        // MDX Components
        components={{
          h1: (props) => <h1 {...props} className="text-4xl" />,
        }}
      />
    </div>
  );
}
```

```tsx tab="Browser (React)"
import { docs } from "content/docs.browser";
import { useRenderer } from "fuma-content/collections/mdx/react";

function Page({ id }: { id: string }) {
  const file = docs.get(id);
  if (!file) return;

  const children = useRenderer(file, (compiled) => {
    const { default: MDX } = compiled;
    return <MDX />;
  });

  return <div className="prose">{children}</div>;
}
```

### Lazy Mode

It leverages async imports to support lazy loading, or lazy compilation (Vite only).

```ts title="content.config.ts"
import { defineConfig } from "fuma-content/config";
import { mdxCollection } from "fuma-content/collections/mdx";

const docs = mdxCollection({
  dir: "content",
  // [!code ++]
  lazy: true,
});
```

The compiled properties now require calling `load()` to access.

```tsx tab="Server"
import { docs } from "content/docs";

for (const file of docs.list()) {
  const id = file.id;
  // typed frontmatter
  console.log(file.frontmatter);
  // compiled properties
  console.log(await file.load());
}
```

```tsx tab="Server (React)"
function Page({ id }: { id: string }) {
  const file = docs.get(id);
  if (!file) return;

  // default refers to the content body renderer
  // you can render it directly in React Server Component
  const { default: MDX } = await file.load();

  return (
    <div className="prose">
      <MDX
        // MDX Components
        components={{
          h1: (props) => <h1 {...props} className="text-4xl" />,
        }}
      />
    </div>
  );
}
```

Lazy mode only effects the server-side integration, client-side usage is not changed.

### Post Process

You can store build-time properties and access them at runtime.

- `processedMarkdown`: the processed Markdown content, useful for generating content for LLM.
- `mdast`: the processed MDAST, useful for runtime AST analysis.
- `linkReferences`: extract link references (e.g. href), useful for reference analysis.

```ts
import { defineConfig } from "fuma-content/config";
import { mdxCollection } from "fuma-content/collections/mdx";
import { z } from "zod";

const docs = mdxCollection({
  dir: "content",
  postprocess: {
    processedMarkdown: true,
    // or
    processedMarkdown: { as: "markdownContent" },

    mdast: true,
    // or
    mdast: { as: "ast" },

    linkReferences: true,
    // or
    linkReferences: { as: "links" },
  },
});
```

Fuma Content will generate types automatically.
